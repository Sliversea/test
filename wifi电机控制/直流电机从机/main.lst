C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\out\main.obj
COMPILER INVOKED BY: C:\program\keil\C51\BIN\C51.EXE src\main.c BROWSE DEBUG OBJECTEXTEND PRINT(.\main.lst) OBJECT(.\out
                    -\main.obj)

line level    source

   1          #include "config.h"
   2          
   3          uchar   uart1_wr;               //写指针
   4          uchar   uart1_rd;               //读指针
   5          uchar   xdata RX1_Buffer[BUF_LENTH];    //接收缓冲
   6          uchar   xdata mbus_buffer[255];
   7          uchar   xdata mbus_Sendbuf[255];
   8          uchar   xdata Crc_buf[2];  //声明存储CRC校验值的高8位及低8位的缓存
   9          
  10          uint  Crc_return_data;  //声明CRC校验值
  11          //***************更多功率参数设置可详细参考DATACC1100英文文档中第48-49页的参数表******************
  12          //uchar PaTabel[8] = {0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04 ,0x04};  //-30dBm   功率最小
  13          uchar PaTabel[8] = {0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60 ,0x60};  //0dBm
  14          //uchar PaTabel[8] = {0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0 ,0xC0};   //10dBm     功率最大
  15          //*****************************************************************************************
  16          
  17          uchar devid;
  18          uchar leng =0;
  19          uchar leng_w = 0;
  20          uchar flag;
  21          uchar flag1 = 1;
  22          uchar flag2;
  23          uchar flag3;
  24          uchar i;
  25          uint j;
  26          uint T0_flag = 0;
  27          
  28          
  29          uchar TxBuf[20]={"www.frotech.com"};     // 8字节, 如果需要更长的数据包,请正确设置
  30          extern unsigned char xdata Sensor_Data[5];
  31          extern unsigned char xdata BUF[8];  //接收数据缓存区
  32          
  33          extern float temp_disp;   //温度显值
  34          extern float humi_disp;   //湿度显值
  35          extern uchar temp_H;        //全局应答变量
  36          extern uchar temp_L;        //全局应答变量
  37          
  38          unsigned char code F_Rotation[4]={0x02,0x04,0x08,0x10};//正转表格
  39          unsigned char code B_Rotation[4]={0x10,0x08,0x04,0x02};//反转表格
  40          unsigned char temp1,temp2,temp3 ;
  41                  
  42          bit             B_TI;
  43          
  44          void zhudong();
  45          void Read_Sense(void);
  46          void Write_Sense(void);
  47          
  48          void Time0_init(void);
  49          
  50          void Delay(unsigned int i);
  51          
  52          
  53          
  54          void    main(void)
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 2   

  55          {
  56   1          
  57   1              Sensor_SDA = 1;
  58   1              GF3658_init();
  59   1              uart1_init();
  60   1      
  61   1              Init_ADXL345(); //初始化ADXL345
  62   1              devid=Single_Read_ADXL345(0X00);
  63   1              Uart1_TxByte(devid);
  64   1      
  65   1              ADC_CONTR = ADC_360T | ADC_ON;
  66   1      
  67   1              EEPROM_read_n(0x0000,mbus_buffer,255);
  68   1              Uart1_String("www.1.com");
  69   1      
  70   1      
  71   1              //Time0_init();
  72   1      
  73   1      
  74   1              mbus_buffer[0x50] = 0x1C;
  75   1              mbus_buffer[0x54] = 0x0E;
  76   1              mbus_buffer[0x55] = 0x08;
  77   1      
  78   1              while(flag1)  //是否初始化标志
  79   1              {
  80   2                   if(mbus_buffer[0x03] == 1)          //RX1 :05 31 (00 05 01 01--配置信息mbus_buff) mbus_buffer: 05 03 00 28 
             -00 01 05 86          
  81   2                       {
  82   3                           flag1 = 0;
  83   3                       }
  84   2                   if(flag == 1) //串口是否有数据
  85   2                       {
  86   3                           delay_ms(1);                                                                        
  87   3                           uart1_wr = 0;
  88   3                           flag = 0;
  89   3                               if((RX1_Buffer[0] == 0xFF) && (RX1_Buffer[1] == 0x30))            //RX1_Buffer:FF 30 00 05 01 01
  90   3                               {
  91   4                                   for(i = 0; i < 4; i++)
  92   4                                       {
  93   5                                       mbus_buffer[i] = RX1_Buffer[i+2];
  94   5                                           EEPROM_write_byte(0x0000, mbus_buffer, 255, i, RX1_Buffer[i+2]);
  95   5                                               mbus_Sendbuf[i + 2] = mbus_buffer[i];
  96   5                                       }
  97   4                                       mbus_Sendbuf[0] = mbus_buffer[1];               //mbus_Sendbuf:05 30 00 05 01 01 
  98   4                                       mbus_Sendbuf[1] = 0x30;
  99   4                                       for(i = 0; i < 6; i++)
 100   4                                       {
 101   5                                            Uart1_TxByte( mbus_Sendbuf[i]);
 102   5                                       }
 103   4                               } 
 104   3                               if((RX1_Buffer[0] == 0xFF) && (RX1_Buffer[1] == 0x31))   //发送FF 31 mbus_Sendbuf：05 31 (00 05 01 01-
             --配置信息mbus_buffer） 
 105   3                               {
 106   4                                  mbus_Sendbuf[0] = mbus_buffer[1];              //mbus_buffer:
 107   4                                      mbus_Sendbuf[1] = 0x31;
 108   4                                      for(i = 0; i < 4; i++)
 109   4                                      {
 110   5                                           mbus_Sendbuf[i + 2] = mbus_buffer[i];      //mbus_Sendbuf:05 03 00 28 00 01 05 86    mbus_buffer:05 03 
             -02 00 00 49 84
 111   5                                      }
 112   4                                  for(i = 0; i < 6; i++)
 113   4                                      {
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 3   

 114   5                                               Uart1_TxByte( mbus_Sendbuf[i]);
 115   5                                      } 
 116   4                               }
 117   3                               
 118   3                      
 119   3                       }
 120   2                                                                               
 121   2              }
 122   1               if(mbus_buffer[0x02] == 0x01)
 123   1               {
 124   2                       CpuInit();
 125   2                   POWER_UP_RESET_CC1100();
 126   2                   halRfWriteRfSettings();
 127   2                   halSpiWriteBurstReg(CCxxx0_PATABLE, PaTabel, 8);        
 128   2               }
 129   1      
 130   1      
 131   1                       Uart1_String("www.2.com");
 132   1      
 133   1              while(1)
 134   1              {
 135   2                        
 136   2      
 137   2                  /**********本部分在扫描数码管的时候开启**********/
 138   2      
 139   2                      /*GF3658_data(mbus_buffer[0x50]);
 140   2                      GF3658_map(mbus_buffer[0x54]);
 141   2                      GF3658_map(mbus_buffer[0x55]);
 142   2              
 143   2      
 144   2      
 145   2                      GF3658_map(9);
 146   2                      GF3658_map(10);
 147   2                      GF3658_map(11);
 148   2                      GF3658_map(12);*/       
 149   2                      /************************************************/
 150   2      
 151   2                      /*if((0 <= T0_flag) && (T0_flag <= 800))
 152   2                      {
 153   2                           COM4 = 1;
 154   2                       set1 = 0;
 155   2                               delay_GF();
 156   2                               COM4 = 0;
 157   2                       set1 = 1;
 158   2                      }
 159   2              if((801 <= T0_flag) && (T0_flag <= 1600))
 160   2                      {
 161   2                           COM4 = 1;
 162   2                       set1 = 0; 
 163   2                               set2 = 0;    
 164   2                       delay_GF();
 165   2                               COM4 = 0;
 166   2                       set1 = 1; 
 167   2                               set2 = 1; 
 168   2                       
 169   2                      }
 170   2                      if((1601 <= T0_flag) && (T0_flag <= 2400))
 171   2                      {
 172   2                           COM4 = 1;
 173   2                       set1 = 0; 
 174   2                               set2 = 0; 
 175   2                               set3 = 0;   
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 4   

 176   2                       delay_GF();
 177   2                               COM4 = 0;
 178   2                       set1 = 1; 
 179   2                               set2 = 1;
 180   2                               set3 = 1;
 181   2                      }
 182   2                      if((2401 <= T0_flag) && (T0_flag <= 3200))
 183   2                      {
 184   2                           COM4 = 1;
 185   2                       set1 = 0; 
 186   2                               set2 = 0; 
 187   2                               set3 = 0;  
 188   2                               set4 = 0; 
 189   2                       delay_GF();
 190   2                               COM4 = 0;
 191   2                       set1 = 1; 
 192   2                               set2 = 1;
 193   2                               set3 = 1;
 194   2                               set4 = 1;
 195   2                      }
 196   2                      if( TF0 == 1)
 197   2                      {
 198   2                          TF0 == 0;
 199   2                          TH0 = 0xfC;
 200   2                              TL0 = 0x67;
 201   2                              T0_flag++;
 202   2                              if(T0_flag == 3700)
 203   2                      {
 204   2                         T0_flag = 0;
 205   2                      }
 206   2                      }*/
 207   2                      leng=63;
 208   2                  if(mbus_buffer[0x02] == 0x01)
 209   2                      {
 210   3                          
 211   3                          leng=63;
 212   3                          if(halRfReceivePacket(RX1_Buffer,&leng))
 213   3                              {
 214   4                                   
 215   4                                   delay_ms(50);
 216   4                                   if(RX1_Buffer[0] == mbus_buffer[0x01])
 217   4                               { 
 218   5                                 if(RX1_Buffer[1] == 0x03)
 219   5                                 {
 220   6                             
 221   6                             Read_Sense();
 222   6                                 }
 223   5                                         if(RX1_Buffer[1] == 0x10)
 224   5                                 {
 225   6                                              Uart1_TxByte('%');
 226   6                              Write_Sense();
 227   6                                 }
 228   5                               }
 229   4      
 230   4                                       if((RX1_Buffer[0] == 0xFF) && (RX1_Buffer[1] == 0x30))
 231   4                                   {
 232   5                                       for(i = 0; i < 4; i++)
 233   5                                           {
 234   6                                           mbus_buffer[i] = RX1_Buffer[i+2];
 235   6                                                       mbus_Sendbuf[i+2]= mbus_buffer[i];
 236   6                                               EEPROM_write_byte(0x0000, mbus_buffer, 255, i, RX1_Buffer[i+2]); 
 237   6                                           }
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 5   

 238   5                                               mbus_Sendbuf[1]= 0x30;
 239   5                                       halRfSendPacket(mbus_Sendbuf, 6);
 240   5                                      
 241   5                                   }
 242   4      
 243   4                                       if((RX1_Buffer[0] == 0xFF) && (RX1_Buffer[1] == 0x31))
 244   4                               {
 245   5                                          for(i = 0; i < 4; i++)
 246   5                                          {
 247   6                                                       mbus_Sendbuf[i+2]= mbus_buffer[i];   
 248   6                                          }
 249   5                                              mbus_Sendbuf[1]= 0x31;
 250   5                                              //delay_ms(((mbus_buffer[0] & 0xFF))*10);
 251   5                                      halRfSendPacket(mbus_Sendbuf, 6);
 252   5                               }
 253   4      
 254   4                              }
 255   3      
 256   3                          
 257   3                      }
 258   2      
 259   2                  if(flag == 1)
 260   2                      {
 261   3                         delay_ms(3);                                                                  
 262   3                         uart1_wr = 0;
 263   3                         flag = 0;
 264   3                         if(RX1_Buffer[0] == mbus_buffer[0x01])
 265   3                         { 
 266   4                             if(RX1_Buffer[1] == 0x03)
 267   4                             {
 268   5                             
 269   5                         Read_Sense();
 270   5                                         
 271   5                             }
 272   4                                 if(RX1_Buffer[1] == 0x10)
 273   4                                 {
 274   5                                     Uart1_String("www.3.com");
 275   5                                     Write_Sense();
 276   5      
 277   5                                 }
 278   4                         }
 279   3                         if((RX1_Buffer[0] == 0xFF) && (RX1_Buffer[1] == 0x30))
 280   3                         {
 281   4                                   for(i = 0; i < 4; i++)
 282   4                                       {
 283   5                                       mbus_buffer[i] = RX1_Buffer[i+2];
 284   5                                           EEPROM_write_byte(0x0000, mbus_buffer, 255, i, RX1_Buffer[i+2]); 
 285   5                                               mbus_Sendbuf[i + 2] = mbus_buffer[i];
 286   5                                       }
 287   4                                       mbus_Sendbuf[0] = mbus_buffer[1];
 288   4                                       mbus_Sendbuf[1] = 0x30;
 289   4                                       for(i = 0; i < 6; i++)
 290   4                                       {
 291   5                                            Uart1_TxByte( mbus_Sendbuf[i]);
 292   5                                       }
 293   4                        }
 294   3                         if((RX1_Buffer[0] == 0xFF) && (RX1_Buffer[1] == 0x31))
 295   3                         {
 296   4                                  mbus_Sendbuf[0] = mbus_buffer[1];
 297   4                                      mbus_Sendbuf[1] = 0x31;
 298   4                                      for(i = 0; i < 4; i++)
 299   4                                      {
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 6   

 300   5                                           mbus_Sendbuf[i + 2] = mbus_buffer[i];
 301   5                                      }
 302   4                                  for(i = 0; i < 6; i++)
 303   4                                      {
 304   5                                               Uart1_TxByte( mbus_Sendbuf[i]);
 305   5                                      } 
 306   4                         }
 307   3      
 308   3                      }
 309   2      
 310   2              }
 311   1      }
 312          
 313          void Write_Sense(void)
 314          {
 315   1              
 316   1          leng_w = (RX1_Buffer[6] + 7);
 317   1          Crc_return_data=cal_crc(RX1_Buffer, leng_w);  //取得将要发送数据的CRC值
 318   1              Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 319   1              Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 320   1      
 321   1              
 322   1              if((RX1_Buffer[leng_w] == Crc_buf[1]) && (RX1_Buffer[1 + leng_w] == Crc_buf[0]))
 323   1              {       
 324   2                      
 325   2                           //LED显示模块
 326   2                       if(RX1_Buffer[0x03] == 0x50)
 327   2                       {
 328   3                 
 329   3                       mbus_buffer[0x50] = RX1_Buffer[0x0A];
 330   3                               mbus_buffer[0x54] = RX1_Buffer[0x0B];
 331   3                               mbus_buffer[0x55] = RX1_Buffer[0x0C];
 332   3                                       if(mbus_buffer[0x02] == 0x01)
 333   3                                   {
 334   4                                       halRfSendPacket(RX1_Buffer, 15);
 335   4                                   }
 336   3                                   else
 337   3                                   {
 338   4                                       for(i = 0; i < 15; i++)
 339   4                                   {             
 340   5                                               Uart1_TxByte(RX1_Buffer[i]);   
 341   5                                   }
 342   4                                   }
 343   3      
 344   3                       }
 345   2      
 346   2                               if(RX1_Buffer[0x03] == 0x4A)
 347   2                       {
 348   3                                        temp1 = P1;
 349   3                        //temp1 = P1^5;                      
 350   3                                        //temp2 = P1^6;
 351   3                                        //temp3 = P1^7;
 352   3      
 353   3                        if(RX1_Buffer[7] == 0x01)
 354   3                        {
 355   4                             for(j = 0; j < RX1_Buffer[8]; j++)
 356   4                             {
 357   5                                 for(i=0;i<4;i++)      //4相
 358   5                                 {
 359   6                                                            
 360   6                                        P1=F_Rotation[i];;  //输出对应的相 可以自行换成反转表格
 361   6                                        Delay(1500);
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 7   

 362   6                                                                Delay(500);
 363   6                                    }
 364   5                             }
 365   4                        }
 366   3                        
 367   3                  
 368   3                        
 369   3                        if(RX1_Buffer[7] == 0x02)
 370   3                        {
 371   4                             for(j = 0; j < RX1_Buffer[8]; j++)
 372   4                             {
 373   5                                 for(i=0;i<4;i++)      //4相
 374   5                                 {
 375   6                                        P1=B_Rotation[i];  //输出对应的相 可以自行换成反转表格
 376   6                                        Delay(1500);
 377   6                                                                Delay(500);                       
 378   6                                  
 379   6                                     }
 380   5                             }
 381   4                        }
 382   3      
 383   3                                        P1 = temp1;
 384   3                                        //P1^5 = temp1;                      
 385   3                                        //P1^6 = temp2;
 386   3                                        //P1^7 = temp3;
 387   3                                       
 388   3      
 389   3                       }
 390   2      
 391   2                      
 392   2                         //直流电机模块
 393   2                    if(RX1_Buffer[0x03] == 0x48)
 394   2                    {
 395   3                                       Uart1_String("www.4.com");
 396   3                         P1M0 |= 0x02;
 397   3                        if(RX1_Buffer[0x08] == 0x01)
 398   3                           {
 399   4                               Uart1_String("www.5.com");
 400   4                                      shuchu = 0;
 401   4                                      
 402   4                           }
 403   3                           else
 404   3                          {
 405   4                               Uart1_String("www.6.com");
 406   4                              shuchu = 1;
 407   4                          }
 408   3              }
 409   2      
 410   2      
 411   2      
 412   2      
 413   2      
 414   2      
 415   2      
 416   2                      
 417   2              }
 418   1      }
 419          
 420          
 421          void zhudong(void)
 422          {
 423   1          if(mbus_buffer[0x01] == 1)
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 8   

 424   1              {
 425   2                  if(mbus_buffer[0x04] > 0xFA)
 426   2                      {
 427   3                         mbus_buffer[0x04] = 0x05; 
 428   3                      }
 429   2                      
 430   2                  while(1)
 431   2                      {
 432   3                          delay_ms(mbus_buffer[0x04]);
 433   3                              delay_ms(mbus_buffer[0x04]);
 434   3                          
 435   3                          Read_Sense();
 436   3                        
 437   3      
 438   3      
 439   3      
 440   3                      }
 441   2              }
 442   1      }
 443          
 444          void Read_Sense(void)
 445          {
 446   1          Crc_return_data=cal_crc(RX1_Buffer, 6);  //取得将要发送数据的CRC值
 447   1              Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 448   1              Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 449   1              if((RX1_Buffer[6] == Crc_buf[1]) && (RX1_Buffer[7] == Crc_buf[0]))
 450   1              {
 451   2                  //温湿度传感器
 452   2          if(RX1_Buffer[0x03] == 0x14)
 453   2              {                  
 454   3                                 Read_Sensor();            //采集温湿度值
 455   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2);  
 456   3                                 for(i = 0; i < 4; i++)
 457   3                             {             
 458   4                                          mbus_Sendbuf[3 + i] = Sensor_Data[i];       
 459   4                             }
 460   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 461   3                                 mbus_Sendbuf[1] = 0x03;
 462   3                                 
 463   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 7);  //取得将要发送数据的CRC值
 464   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 465   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 466   3                                 mbus_Sendbuf[7]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 467   3                                 mbus_Sendbuf[8]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 468   3                                 if(mbus_buffer[0x02] == 0x01)
 469   3                                 {
 470   4                                     halRfSendPacket(mbus_Sendbuf, 9);
 471   4                                 }
 472   3                                 else
 473   3                                 {
 474   4                                     for(i = 0; i < 9; i++)
 475   4                                 {             
 476   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 477   5                                 }
 478   4                                 }
 479   3              }
 480   2                              //加速度传感器
 481   2              if(RX1_Buffer[0x03] == 0x18)
 482   2              {                       //
 483   3                                 if(devid == 0xE5) //读出的数据为0XE5,表示正确读出器件的ID号  
 484   3                             {
 485   4                                     mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2);
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 9   

 486   4                                 Multiple_Read_ADXL345();             //连续读出数据，存储在BUF中
 487   4                                 for(i=0; i<6; i++)
 488   4                                 {
 489   5                                       mbus_Sendbuf[i+3] = BUF[i];
 490   5                                 }
 491   4                                         mbus_Sendbuf[0] = mbus_buffer[1];  
 492   4                                     mbus_Sendbuf[1] = 0x03;
 493   4                                       
 494   4                                 
 495   4                                     Crc_return_data=cal_crc(mbus_Sendbuf, 10);  //取得将要发送数据的CRC值
 496   4                             Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 497   4                             Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 498   4                                     mbus_Sendbuf[9]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 499   4                                     mbus_Sendbuf[10]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 500   4                                     if(mbus_buffer[0x02] == 0x01)
 501   4                                     { 
 502   5                                         halRfSendPacket(mbus_Sendbuf, 11);
 503   5                                     }
 504   4                                     else
 505   4                                    {
 506   5                                         for(i = 0; i < 11; i++)
 507   5                                     {             
 508   6                                                  Uart1_TxByte(mbus_Sendbuf[i]);      
 509   6                                     }        
 510   5                                    }
 511   4                             }    
 512   3                                
 513   3              }
 514   2                              //磁控检测传感器
 515   2              if(RX1_Buffer[0x03] == 0x28)      //RX1_Buffer：05 03 00 28 00 01 05 86  mbus_Sendbuf：05 03 02 00 00 49 84 
             -;
 516   2              {
 517   3                                 mbus_Sendbuf[3] = 0x00;
 518   3                                 mbus_Sendbuf[4] = 0x00;
 519   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2);        // 00*16+01*2=2
 520   3                                 if(P1_0 == 0)
 521   3                                 {
 522   4                                     mbus_Sendbuf[4] = 0x01;          //mbus_Sendbu:05 03 02 00 01 88 44
 523   4                                 }
 524   3                                 mbus_Sendbuf[0] = mbus_buffer[1];      //mbus_buffer:05 31 00 05 01 01       配置信息
 525   3                                 mbus_Sendbuf[1] = 0x03;
 526   3                                   
 527   3                              
 528   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 529   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 530   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 531   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 532   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 533   3                                 if(mbus_buffer[0x02] == 0x01) //00 05 01 01
 534   3                                 {
 535   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 536   4                                 }
 537   3                                 else
 538   3                                 {
 539   4                                     for(i = 0; i < 7; i++)
 540   4                                 {             
 541   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 542   5                                 }    
 543   4                                 }
 544   3              }
 545   2                              //光敏传感器
 546   2              if(RX1_Buffer[0x03] == 0x2A)    //09 03 00 2A 00 01 a4 8a         mbus_Sendbuf：09 03 02 02 E7 18 AF 
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 10  

 547   2              {
 548   3      
 549   3                                 P1ASF = (1 << ADC_CH1);      //STC12C5A16S2系列模拟输入(AD)选择ADC1(P1.1)
 550   3                                 j = adc10_start(1);  //(P1.1)ADC1转换
 551   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2);  //  00*4+01*2=2
 552   3                                 mbus_Sendbuf[3] = ((j >> 8) & 0xFF);
 553   3                                 mbus_Sendbuf[4] = (j & 0xFF);
 554   3      
 555   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 556   3                                 mbus_Sendbuf[1] = 0x03;
 557   3                                   
 558   3                                
 559   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 560   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 561   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 562   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 563   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 564   3                                 if(mbus_buffer[0x02] == 0x01)
 565   3                                 {
 566   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 567   4                                 }
 568   3                                 else
 569   3                                 {
 570   4                                     for(i = 0; i < 7; i++)
 571   4                                 {             
 572   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 573   5                                 }    
 574   4                                 }
 575   3              }
 576   2                              //红外对射传感器
 577   2              if(RX1_Buffer[0x03] == 0x2C)
 578   2              {
 579   3      
 580   3                                 P1ASF = (1 << ADC_CH0);      //STC12C5A16S2系列模拟输入(AD)选择ADC1(P1.1)
 581   3                                 j = adc10_start(0);  //(P1.1)ADC1转换
 582   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2); 
 583   3                                 mbus_Sendbuf[3] = ((j >> 8) & 0xFF);
 584   3                                 mbus_Sendbuf[4] = (j & 0xFF);
 585   3      
 586   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 587   3                                 mbus_Sendbuf[1] = 0x03;
 588   3                                  
 589   3                                
 590   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 591   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 592   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 593   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 594   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 595   3                                 if(mbus_buffer[0x02] == 0x01)
 596   3                                 {
 597   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 598   4                                 }
 599   3                                 else
 600   3                                 {
 601   4                                     for(i = 0; i < 7; i++)
 602   4                                 {             
 603   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 604   5                                 }    
 605   4                                 }
 606   3              }
 607   2                              //结露传感器
 608   2              if(RX1_Buffer[0x03] == 0x2E)
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 11  

 609   2              {
 610   3      
 611   3                                 P1ASF = (1 << ADC_CH1);      //STC12C5A16S2系列模拟输入(AD)选择ADC1(P1.1)
 612   3                                 j = adc10_start(1);  //(P1.1)ADC1转换
 613   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2);
 614   3                                 mbus_Sendbuf[3] = ((j >> 8) & 0xFF);
 615   3                                 mbus_Sendbuf[4] = (j & 0xFF);
 616   3      
 617   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 618   3                                 mbus_Sendbuf[1] = 0x03;
 619   3                                    
 620   3                      
 621   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 622   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 623   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 624   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 625   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 626   3                                 if(mbus_buffer[0x02] == 0x01)
 627   3                                 {
 628   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 629   4                                 }
 630   3                                 else
 631   3                                 {
 632   4                                     for(i = 0; i < 7; i++)
 633   4                                 {             
 634   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 635   5                                 }    
 636   4                                 }
 637   3              }
 638   2                              //酒精传感器
 639   2              if(RX1_Buffer[0x03] == 0x30)
 640   2              {
 641   3      
 642   3                                 P1ASF = (1 << ADC_CH1);      //STC12C5A16S2系列模拟输入(AD)选择ADC1(P1.1)
 643   3                                 j = adc10_start(1);  //(P1.1)ADC1转换
 644   3                                 
 645   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 646   3                                 mbus_Sendbuf[1] = 0x03;
 647   3      
 648   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2); 
 649   3                                 mbus_Sendbuf[3] = ((j >> 8) & 0xFF);
 650   3                                 mbus_Sendbuf[4] = (j & 0xFF);
 651   3                              
 652   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 653   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 654   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 655   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 656   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 657   3                                 if(mbus_buffer[0x02] == 0x01)
 658   3                                 {
 659   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 660   4                                 }
 661   3                                 else
 662   3                                 {
 663   4                                     for(i = 0; i < 7; i++)
 664   4                                 {             
 665   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 666   5                                 }    
 667   4                                 }
 668   3              }
 669   2                              //振动传感器
 670   2              if(RX1_Buffer[0x03] == 0x32)
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 12  

 671   2              {
 672   3                         flag3 = 1;
 673   3                                 while(flag3)
 674   3                                 {
 675   4                                     if(P1_0 == 0)
 676   4                                     {
 677   5                                             flag3 = 0;
 678   5                                         mbus_Sendbuf[0] = mbus_buffer[1];  
 679   5                                         mbus_Sendbuf[1] = 0x03;
 680   5                                         mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2);   
 681   5                                     
 682   5                                                 mbus_Sendbuf[3] = 0x00;
 683   5                                                 mbus_Sendbuf[4] = 0x01;  
 684   5                                         Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 685   5                                 Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 686   5                                 Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 687   5                                         mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 688   5                                         mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 689   5                                         if(mbus_buffer[0x02] == 0x01)
 690   5                                         {
 691   6                                             halRfSendPacket(mbus_Sendbuf, 7);
 692   6                                         }
 693   5                                         else
 694   5                                         {
 695   6                                         for(i = 0; i < 7; i++)
 696   6                                     {             
 697   7                                                  Uart1_TxByte(mbus_Sendbuf[i]);      
 698   7                                     }        
 699   6                                         }
 700   5                                     }
 701   4                                        
 702   4                                        
 703   4                                 }
 704   3              }
 705   2                      
 706   2                              //烟雾传感器
 707   2              if(RX1_Buffer[0x03] == 0x34)
 708   2              {
 709   3      
 710   3                                 P1ASF = (1 << ADC_CH1);      //STC12C5A16S2系列模拟输入(AD)选择ADC1(P1.1)
 711   3                                 j = adc10_start(1);  //(P1.1)ADC1转换
 712   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2); 
 713   3                                 mbus_Sendbuf[3] = ((j >> 8) & 0xFF);
 714   3                                 mbus_Sendbuf[4] = (j & 0xFF);
 715   3      
 716   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 717   3                                 mbus_Sendbuf[1] = 0x03;
 718   3                                   
 719   3                               
 720   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 721   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 722   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 723   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 724   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 725   3                                 if(mbus_buffer[0x02] == 0x01)
 726   3                                 {
 727   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 728   4                                 }
 729   3                                 else
 730   3                                 {
 731   4                                     for(i = 0; i < 7; i++)
 732   4                                 {             
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 13  

 733   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 734   5                                 }    
 735   4                                 }
 736   3              }
 737   2              //红外反射传感器
 738   2              if(RX1_Buffer[0x03] == 0x36)
 739   2              {
 740   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2); 
 741   3                                 mbus_Sendbuf[3] = 0x00;
 742   3                                 mbus_Sendbuf[4] = 0x00;
 743   3                                 if(P1_0 == 0)
 744   3                                 {
 745   4                                     mbus_Sendbuf[4] = 0x01;
 746   4                                 }
 747   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 748   3                                 mbus_Sendbuf[1] = 0x03;
 749   3                                  
 750   3                              
 751   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 752   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 753   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 754   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 755   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 756   3                                 if(mbus_buffer[0x02] == 0x01)
 757   3                                 {
 758   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 759   4                                 }
 760   3                                 else
 761   3                                 {
 762   4                                     for(i = 0; i < 7; i++)
 763   4                                 {             
 764   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 765   5                                 }    
 766   4                                 }
 767   3              }
 768   2              //火焰传感器
 769   2              if(RX1_Buffer[0x03] == 0x38)
 770   2              {
 771   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2); 
 772   3                                 mbus_Sendbuf[3] = 0x00;
 773   3                                 mbus_Sendbuf[4] = 0x00;
 774   3                                 if(P1_0 == 0)
 775   3                                 {
 776   4                                     mbus_Sendbuf[4] = 0x01;
 777   4                                 }
 778   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 779   3                                 mbus_Sendbuf[1] = 0x03;
 780   3                                 
 781   3                              
 782   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 783   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 784   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 785   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 786   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 787   3                                 if(mbus_buffer[0x02] == 0x01)
 788   3                                 {
 789   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 790   4                                 }
 791   3                                 else
 792   3                                 {
 793   4                                     for(i = 0; i < 7; i++)
 794   4                                 {             
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 14  

 795   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 796   5                                 }    
 797   4                                 }
 798   3              }
 799   2              //声音传感器
 800   2              if(RX1_Buffer[0x03] == 0x3A)
 801   2              {
 802   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2);
 803   3                                 flag3 = 1;
 804   3                                 while(flag3)
 805   3                                 {
 806   4                                     
 807   4                                     if(P1_0 == 0)
 808   4                                     {
 809   5                                             flag3 = 0;
 810   5                                         mbus_Sendbuf[0] = mbus_buffer[1];  
 811   5                                         mbus_Sendbuf[1] = 0x03;
 812   5                                            
 813   5                                     
 814   5                                                 mbus_Sendbuf[3] = 0x00;
 815   5                                                 mbus_Sendbuf[4] = 0x01;  
 816   5                                         Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 817   5                                 Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 818   5                                 Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 819   5                                         mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 820   5                                         mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 821   5                                         if(mbus_buffer[0x02] == 0x01)
 822   5                                         {
 823   6                                             halRfSendPacket(mbus_Sendbuf, 7);
 824   6                                         }
 825   5                                         else
 826   5                                         {
 827   6                                         for(i = 0; i < 7; i++)
 828   6                                     {             
 829   7                                                  Uart1_TxByte(mbus_Sendbuf[i]);      
 830   7                                     }        
 831   6                                         }
 832   5                                     }
 833   4                                        
 834   4                                        
 835   4                                 }
 836   3              }
 837   2      
 838   2          //人体感应传感器
 839   2      
 840   2      
 841   2              //水流量传感器
 842   2      
 843   2      
 844   2              //雨滴检测传感器
 845   2              if(RX1_Buffer[0x03] == 0x40)
 846   2              {
 847   3      
 848   3                                 P1ASF = (1 << ADC_CH1);      //STC12C5A16S2系列模拟输入(AD)选择ADC1(P1.1)
 849   3                                 j = adc10_start(1);  //(P1.1)ADC1转换
 850   3                                 mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2);
 851   3                                 mbus_Sendbuf[3] = ((j >> 8) & 0xFF);
 852   3                                 mbus_Sendbuf[4] = (j & 0xFF);
 853   3      
 854   3                                 mbus_Sendbuf[0] = mbus_buffer[1];  
 855   3                                 mbus_Sendbuf[1] = 0x03;
 856   3                                    
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 15  

 857   3                      
 858   3                                 Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 859   3                         Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 860   3                         Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 861   3                                 mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 862   3                                 mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 863   3                                 if(mbus_buffer[0x02] == 0x01)
 864   3                                 {
 865   4                                     halRfSendPacket(mbus_Sendbuf, 7);
 866   4                                 }
 867   3                                 else
 868   3                                 {
 869   4                                     for(i = 0; i < 7; i++)
 870   4                                 {             
 871   5                                              Uart1_TxByte(mbus_Sendbuf[i]);  
 872   5                                 }    
 873   4                                 }
 874   3              }
 875   2      
 876   2              //压力传感器
 877   2      
 878   2      
 879   2              //超声波测距传感器
 880   2      
 881   2      
 882   2              
 883   2      
 884   2              //步进电机模块
 885   2              
 886   2      
 887   2              //SHT10温湿度模块
 888   2              if(RX1_Buffer[0x03] == 0x4C)
 889   2              {
 890   3                   deal_whole();
 891   3                   
 892   3               mbus_Sendbuf[2] = (((RX1_Buffer[0x04] * 16) + RX1_Buffer[0x05]) * 2); 
 893   3                   mbus_Sendbuf[3] = temp_disp;
 894   3                       mbus_Sendbuf[4] = humi_disp;
 895   3                       mbus_Sendbuf[0] = mbus_buffer[1];  
 896   3                       mbus_Sendbuf[1] = 0x03;
 897   3                                 
 898   3                              
 899   3                       Crc_return_data=cal_crc(mbus_Sendbuf, 5);  //取得将要发送数据的CRC值
 900   3                   Crc_buf[0]=((Crc_return_data >> 8)&0xff);  //取得CRC值的高8位
 901   3                   Crc_buf[1]=(Crc_return_data & 0xff);   //取得CRC值的低8位
 902   3                       mbus_Sendbuf[5]=Crc_buf[1];  //CRC值低8位赋值给将要发送的数据的倒数第二个字节
 903   3                       mbus_Sendbuf[6]=Crc_buf[0];  //CRC值高8位赋值给将要发送的数据的最后一个
 904   3                       if(mbus_buffer[0x02] == 0x01)
 905   3                       {
 906   4                                 halRfSendPacket(mbus_Sendbuf, 7);
 907   4                       }
 908   3                       else
 909   3                       {
 910   4                                 for(i = 0; i < 7; i++)
 911   4                             {             
 912   5                                          Uart1_TxByte(mbus_Sendbuf[i]);      
 913   5                             }        
 914   4                       }    
 915   3              }
 916   2      
 917   2      
 918   2         
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 16  

 919   2      
 920   2      
 921   2      
 922   2              }
 923   1              
 924   1      }
 925          
 926          
 927          
 928          
 929          
 930          
 931          void    uart1_init(void)
 932          {
 933   1              PCON |= 0x80;           //UART0 Double Rate Enable
 934   1              SCON = 0x50;            //UART0 set as 10bit , UART0 RX enable
 935   1              AUXR |=  0x01;          //UART0 使用BRT
 936   1              AUXR |=  0x04;          //BRT set as 1T mode
 937   1              BRT = BRT_Reload;
 938   1              AUXR |=  0x10;          //start BRT     
 939   1      
 940   1              ES  = 1;
 941   1              EA = 1;
 942   1      }
 943          
 944          void Uart1_TxByte(unsigned char dat)
 945          {
 946   1          B_TI = 0;
 947   1              SBUF = dat;
 948   1              while(!B_TI);
 949   1              B_TI = 0;
 950   1      }
 951          
 952          void Uart1_String(unsigned char code *puts)
 953          {
 954   1          for(; *puts != 0; puts++)
 955   1              {
 956   2              Uart1_TxByte(*puts);
 957   2      
 958   2              }
 959   1      }
 960          
 961          
 962          /**********************************************/
 963          void UART1_RCV (void) interrupt 4
 964          {
 965   1              if(RI)
 966   1              {
 967   2                      RI = 0;
 968   2                      RX1_Buffer[uart1_wr++] = SBUF;
 969   2                      flag = 1;
 970   2              }
 971   1      
 972   1              if(TI)
 973   1              {
 974   2                      TI = 0;
 975   2                      B_TI = 1;
 976   2              }
 977   1      }
 978          
 979          void Time0_init(void)
 980          {
C51 COMPILER V9.00   MAIN                                                                  10/22/2020 15:00:38 PAGE 17  

 981   1          AUXR = 0x00;
 982   1              TMOD = 0x01;
 983   1              TL0  = 0x67;
 984   1              TH0  = 0xFC;            
 985   1              TR0  = 1;
 986   1              //ET0  = 1;
 987   1              EA   = 1;
 988   1      }
 989          
 990          /*void T0 (void) interrupt 1
 991          {
 992              TL0  = 0x67;
 993                  TH0  = 0xfC;
 994              T0_flag++;
 995                  if(T0_flag == 3700)
 996                  {
 997                      T0_flag = 0;
 998                  }
 999          
1000          }*/
1001          
1002          void delay_ms(unsigned char ms)
1003          {
1004   1          unsigned int i;
1005   1              do{
1006   2                  i = MAIN_Fosc /1400;
1007   2                      while(--i);
1008   2              }while(--ms);
1009   1      }
1010          
1011          void Delay(unsigned int i)//延时
1012          {
1013   1       while(--i);              
1014   1      }
1015          
1016          
1017          
1018          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3333    ----
   CONSTANT SIZE    =     68    ----
   XDATA SIZE       =    767    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
